# Creating the Hero

In this lesson, we will create the heart of our RPG game: the hero character. This is the character that the player will control throughout the game.

But before we dive into the code, we need to understand some fundamental programming concepts that we'll be using. Don't worry—I'll explain everything step by step, and by the end of this lesson, you'll see how these concepts come together to create something meaningful.

## Understanding Variables

Let's start with the most basic building block of programming: **variables**.

Think of a variable as a labeled box where you can store information. Just like you might have a box labeled "Books" in your room, in programming you can have a variable labeled `name` that stores a player's name.

Here's a simple example:

```python
player_name = "Arthur"
player_health = 100
is_alive = True
```

In these examples:
- `player_name` is a variable that stores the text "Arthur"
- `player_health` is a variable that stores the number 100
- `is_alive` is a variable that stores the value True

The `=` sign is called the **assignment operator**. It doesn't mean "equals" like in math—instead, it means "store this value in this variable." We read it as "player_name is assigned the value Arthur."

## Understanding Data Types

You might have noticed that our variables store different kinds of information. In Python, these different kinds are called **data types**. Here are the most common ones:

- **String** (`str`): Text, always written in quotes. Example: `"Arthur"`, `"Hello, World!"`
- **Integer** (`int`): Whole numbers. Example: `100`, `42`, `-5`
- **Float**: Decimal numbers. Example: `3.14`, `99.9`, `0.5`
- **Boolean** (`bool`): True or False values. Example: `True`, `False`

Python is smart enough to figure out what type of data you're storing, so you don't need to specify it explicitly.

```python
name = "Arthur"        # Python knows this is a string
level = 5              # Python knows this is an integer
health_percent = 87.5  # Python knows this is a float
is_defending = False   # Python knows this is a boolean
```

## Understanding Objects and Classes

Now, here's where things get more interesting. Imagine you're creating a video game with many heroes. Each hero has similar properties: they all have a name, a level, health points, and so on.

Instead of creating separate variables for each hero like this:

```python
hero1_name = "Arthur"
hero1_level = 1
hero1_health = 100

hero2_name = "Merlin"
hero2_level = 5
hero2_health = 150
```

We can use something much more powerful: **classes** and **objects**.

### What is a Class?

A **class** is like a blueprint or a template. Think of it like a cookie cutter. The cookie cutter itself isn't a cookie—it's the shape that defines what all cookies made with it will look like.

In programming terms, a class defines what properties and behaviors something should have.

### What is an Object?

An **object** is an actual instance created from a class. Going back to our cookie cutter analogy, if the class is the cookie cutter, then each cookie you make is an object.

You can make many cookies (objects) from the same cookie cutter (class), and each cookie can have slightly different decorations (different values for its properties).

## Creating the Hero Class

Now let's create our hero! Create a new Python file next to `main.py` called `hero.py` and add the following code:

```python
class Hero:
    def __init__(self, name):
        self.name = name
        self.level = 1
        self.xp = 0
        self.gold = 0
        self.max_energy = 10
        self.energy = self.max_energy
```

Let me break down what's happening here, line by line:

### The Class Definition

```python
class Hero:
```

This line creates a new class called `Hero`. By convention, class names in Python start with a capital letter. The colon (`:`) indicates that everything indented below this line is part of the Hero class.

### The `__init__` Method

```python
    def __init__(self, name):
```

This is a special method called a **constructor** or **initializer**. The `__init__` method is automatically called when you create a new hero object. It sets up the initial state of the hero.

Let's break down this line:
- `def` means we're defining a function (a method, in this case)
- `__init__` is the special name Python recognizes as the constructor
- `self` refers to the object being created (we'll explain this more in a moment)
- `name` is a parameter—information we need to provide when creating a hero

### The `self` Keyword

```python
        self.name = name
```

The `self` keyword represents the specific object being created. When you create a hero named "Arthur," `self` refers to that Arthur hero object.

- `self.name` means "this hero's name attribute"
- `= name` assigns the value from the `name` parameter to this hero's name

Think of `self` as a way for the object to refer to itself. It's like saying "my name" instead of "the name."

### Setting Initial Values

```python
        self.level = 1
        self.xp = 0
        self.gold = 0
        self.max_energy = 10
        self.energy = self.max_energy
```

These lines set up the initial attributes (properties) of every new hero:
- Every hero starts at level 1
- Every hero starts with 0 experience points (xp)
- Every hero starts with 0 gold
- Every hero has a maximum energy of 10
- Every hero starts with full energy (equal to their max energy)

Notice that `name` needs to be provided when creating a hero (it's a parameter), but all these other attributes are set to default values automatically.

## Creating Hero Objects

Now that we have our Hero class, how do we actually create heroes? Here's how you would use this class:

```python
# Create a hero named Arthur
hero1 = Hero("Arthur")

# Create another hero named Merlin
hero2 = Hero("Merlin")

# Each hero has their own separate attributes
print(hero1.name)    # Output: Arthur
print(hero2.name)    # Output: Merlin
print(hero1.level)   # Output: 1
print(hero2.level)   # Output: 1
```

When we write `Hero("Arthur")`, Python:
1. Creates a new Hero object
2. Calls the `__init__` method
3. Passes "Arthur" as the `name` parameter
4. Sets up all the attributes (name, level, xp, gold, max_energy, energy)
5. Returns the new hero object, which we store in the variable `hero1`

Each hero object is independent. If we later change `hero1.level = 5`, it doesn't affect `hero2.level`—they're separate objects with their own data.

## Why Use Classes?

You might be wondering: why go through all this trouble? Why not just use simple variables?

Here are the key benefits:

1. **Organization**: All related data about a hero is grouped together in one place
2. **Reusability**: You can easily create many heroes with the same structure
3. **Maintainability**: If you need to add a new attribute (like `intelligence` or `strength`), you only change the class definition in one place
4. **Real-world modeling**: Classes help you model real-world concepts in your code. A hero in a game naturally has properties and behaviors, and classes let us express that naturally

## What's Next?

We now have a Hero class that can store important information about our player character. But a hero that just sits there with data isn't very interesting—we need our hero to be able to *do* things!

In the next lesson, we'll add methods (functions) to our Hero class that will allow the hero to perform actions like gaining experience, leveling up, and spending energy. This is where our game will really start to come alive.

For now, save your `hero.py` file. We're building the foundation, piece by piece, and you're already learning how real programmers structure their code!

Link to GitHub commit for this code:
[here](https://github.com/euanrussano/PyRPG/commit/e8f4ff9a3b0c6a995e813a0064f60506fbe64901)